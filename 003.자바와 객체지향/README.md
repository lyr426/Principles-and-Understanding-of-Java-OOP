003.자바와 객체지향
===============

### 객체 지향은 인간 지향이다.
- 기존 구조적 프로그래밍에서 가장 중요했던 것은 "함수" </br> 
함수 : 코드를 논리적인 단위로 구분하고 분할해서 정복하자 => **D&C: Devide and Conquer**  
-> 함수로 인해 프로그래밍이 편해진 뒤 객체 지향이라는 제안이 생겨남 </br> 
-> "우리가 주변에서 사물을 인지하는 방식대로 프로그래밍 할 수 있지 않을까" </br> 
-> 객체 지향에서는 우리가 주변에서 실제 사물을 인지 및 사고하는 방식 대로 객체 단위의 프로그래밍이 가능 : **직관적**

---
### 객체 지향의 4대 특성 - 캡! 상추다캡
- 캡슐화 (Encapsulation): 정보 은닉(information hiding) 
- 상속(Inheritance): 재사용
- 추상화(Abstraction): 모델링
- 다형성(Polymorphism): 사용 편의 

---
### 클래스 vs 객체 = 붕어빵틀 vs 붕어빵 ??? 
```
붕어빵틀 붕어빵 = new 붕어빵틀(); 
``` 
위의 코드는 논리에 맞지 않는 코드 : 붕어빵틀과 붕어빵은 클래스와 객체 관계가 아니다. </br>
=> **붕어빵틍은 붕어빵을 만드는 팩터리였던 것** </br>
클래스 : 분류에대한 개념 </br>
객체 : 실체 </br>

---
### 추상화: 모델링 
추상: 여러 가지 사물이나 개념에서 **공통되는 특성이나 속성** 따위를 추출하여 파악하는 작용 

- 추상화는 모델링이다. </br> 
추상화는 구체적인 것을 분해해서 관찰자가 관심 있는 특성만 가지고 재조합 하는 것이다. 
``` 
객체: 세상에 존재하는 유일무이한 사물
클래스: 분류, 집합. 같은 속성과 기능을 가진 객체를 총칭하는 개념 
```

- 클래스를 이용해 object를 만들었다는 것을 강조할 때는 object라는 표현보다 클래스의 인스턴스(instance)라는 표현을 사용 ₩
- 객체(object) = 클래스의 인스턴스 

> 애플리케이션 경계 : 컨텍스트(Context)
>> "내가 만들고자 하는 애플리케이션은 어디에서 사용될 것인가?
: 애플리케이션에 경계에 따라 클래스의 설계가 달라진다.</br> 

**모델링: 목적에 맞게 관심 있는 특성만을 추출해서 실제 사물을 단순하게 묘사** </br>
**자바는 class 키워드를 통해 추상화를 지원한다.**
---
### 클래스 멤버 vs 객체멤버 = static 멤버 vs 인스턴스 멤버 
- static 키워드가 붙은 속성을 클래스 멤버 속성이라고 한다. 
- static 키워드가  붙지 않은 속성은 객체 멤버 속성이라고 한다. 
- static 키워드가 붙은 메서드는 클래스 멤버 메서드 => main()메서드에 static이 항상 붙어 있는 것은 main메서드가 클래스 멤버 메서드이기 때문
- static 키워드가 붙지 않은 메서드는 객체 멤버 메서드라고 한다. 
```
클래스 멤버 = static 멤버 = 정적 멤버 
객체 멤버 = 인스턴스 멤버
```
- 정적 멤버 속성은 해당 클래스의 모든 객체들이 같은 값을 가질 때 사용하는 것이 정석 
- 정적 멤버 메서드는 객체들의 존재 여부에 관계없이 쓸 수 있는 메서드 
  - 정적 멤버는 클래스에 속해 있음. 클래스는 JVM 구동 시 T메모리의 스태틱 영역에 바로 배치되기 때문에 객체의 존재 여부에 관계없이 쓸 수 있다. 
  - main() 메서드의 논리를 함수로 분할해서 사용하는 경우
  - 정적 변수에 대한 접근자 메서드(getter)와 설정자 메서드(setter)로 사용하는 용도 
  - 실무에서는 클래스의 인스턴스를 만들지 않고 사용하게 되는 유틸리티성 메서드를 주로 정적 메서드로 구성 

<세 가지 변수 유형>
|이름|다른 이름|T메모리|
|---|-------|-----|
|static 변수|클래스[멤버]속성, 정적 변수, 정적 속성, ...|스태틱 영역|
|인스턴스 변수|객체[멤버]속성, 객체 변수, ...|힙 영역|
|local 변수|지역 변수|스택 영역|

---
### 상속: 재사용 + 확장 
객체 지향에서의 상속은 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 특성을 추가, 즉 **확장해서 사용할 수 있다는 의미**
=> 상속을 부모 클래스-자식 클래스 보다는 상위-하위 또는 슈퍼-서브라고 하는 표현이 더 적합 

> 상속은 is a 관계를 만족해야 한다? </br> 
하위 클래스는 상위 클래스다라는 표현은 상속관계를 명확히 표현하기 어렵다.</br>
=> "is a kind of" 으로 더 명확하게 표현할 수 있다.</br> 
ex. (하위 클래스 is a kind of 상위클래스) = 펭귄 is a kind of 동물 -> 펭귄은 동물의 한 분류다. 

#### 다중 상속과 자바 
자바에서 다중 상속을 지원하지 않는 이유 => 다중 상속의 다이아몬드 문제 때문: 상속관계가 다중이 되면 함수 호출 등이 모호해짐 

#### 상속과 인터페이스 
- 인터페이스 : 구현 클래스 is able to 인터페이스 => 구현 클래스는 인터페이스 할 수 있다. 
- 상위 클래스는 하위 클래스에게 특성(속성과 메소드)를 상속해주고 인터페이스는 '무엇을 할 수 있다' 라고 하는 기능을 구현하도록 강제하게 된다. 
- 상위 클래스는 하위 클래스에게 물려줄 특성이 많을수록 좋다. => LSP(리스코프 치환 원칙)에 따른 이유 
- 인터페이스는 구현을 강제할 메서드의 개수가 적을수록 좋다. => ISP(인터페이스 분할 원칙)에 따른 이유 

#### 상속과 UML표기 
![image](https://user-images.githubusercontent.com/56033943/210936726-c5df4f1d-da6f-43e1-963f-4ce38f0f2bd1.png)

- 상위클래스를 상속 받은 경우 
- 클래스가 인터페이스를 구현한 경우 

---
### 다형성: 사용편의성 
#### 오버라이딩? 오버로딩? 
- 오버라이딩: 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 재정의 
- 오버로딩: 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의 
-> ride: 올라타다, load: 적재하다. 

#### 다형성과 T메모리 
! 상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩(재정의)한 메서드가 호출된다. 

#### 다형성이 지원되지 않는 언어
- 오버로딩은 함수명 하나를 가지고 인자 목록만 달리하면 된다. 
- 자바5에서 추가된 제네릭을 이용하면 하나의 함수만 구현해도 다수의 함수를 구현한 효과를 낼 수 있다. 
- 오버라이딩의 경우에도 하위 클래스가 재정의한 메서드를 알아서 호출해주기 때문에 형변환이나 instanceof 연산자를 써서 하위 클래스가 무엇인지 신경쓰지 않아도 된다. 

---
### 캡슐화: 정보은닉
#### 객체 멤버의 접근 제어자 
- 상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 객체 참조 변수를 이용해 접근해야 한다. 
- 정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장한다. 

#### 참조 변수의 복사 
- CallByValue
```
int a = 10; 
int b = a;

b=20;

System.out.println(a); //10
System.out.println(b); //20
```
- CallByReference Or CallByAddress
```
Animal ref_a = new Animal();
Animal ref_b = ref_a; 

ref_a.age = 10;
ref_b.age = 20; 

System.out.println(ref_a.age); //20
System.out.println(ref_b.age); //20
```
=> 기본 자료형 변수는 저장하고 있는 값을 그 값 자체로 해석하지만, 객체 참조 변수는 저장하고 있는 값을 주소로 해석한다. 
